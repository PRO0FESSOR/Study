[ ONE SHOT ]


[ BACKEND ]

- In tech, backend refers to the server-side of an application that handles logic, databases, authentication, and communication with the frontend. It processes requests, executes business logic, and manages data storage.
- Django is a high-level Python web framework that simplifies web development by providing built-in features like authentication, database management, and security.
- Django features MVC/MVT architecture, a built-in admin panel, ORM for database interaction, robust security (protecting against SQL injection, CSRF, XSS), and high scalability (used by Instagram, Pinterest).

[ INSTALLATION ]

- sudo pacman -S python python-pip  # Install Python , Pip , Virtual Env
- python --version                  # Check Python version  
- pip --version                     # Check pip version  
- python -m venv venv_name          # Create virtual environment 
- source venv_name/bin/activate     # Activate venv (Linux/macOS)  
- venv_name\Scripts\activate        # Activate venv (Windows)  
- pip install django                # Install Django  
- django-admin --version            # Check Django version  
- deactivate                        # Deactivate virtual environment

[ MAJOR COMMANDS ]

- django-admin startproject project_name   # Create a new project  
- cd project_name                          # Navigate to project folder  
- python manage.py runserver               # Start development server  

- Create and manage apps
- python manage.py startapp app_name       # Create a new app  

- Migrations and database managements
- python manage.py makemigrations                        # Generate migration files  
- python manage.py migrate                               # Apply migrations  
- python manage.py showmigrations                        # Show applied migrations  
- python manage.py sqlmigrate app_name migration_number  # View SQL for a migration  

- User and admin management 
- python manage.py createsuperuser         # Create admin user  
- python manage.py changepassword username # Change user password  

- Debugging and testing
- python manage.py check       # Check for project errors  
- python manage.py test        # Run tests  

- Collect static files
- python manage.py collectstatic           # Collect static files  

[ DJANGO PROJECT DIRECTORY ]

my_project/          # Root project directory
│── manage.py        # Command-line utility for managing Django project
│── db.sqlite3       # Default SQLite database file (if used)
│── my_project/      # Main project package
│   │── __init__.py  # Marks this as a Python package
│   │── settings.py  # Main configuration file (database, middleware, installed apps, etc.)
│   │── urls.py      # Defines URL routing for the project
│   │── wsgi.py      # WSGI entry point for web servers (for deployment)
│   │── asgi.py      # ASGI entry point (for async support)
│── my_app/          # A Django application (each feature can be a separate app)
│   │── migrations/  # Stores migration files for database changes
│   │── __init__.py  # Marks this as a Python package
│   │── admin.py     # Registers models in Django admin panel
│   │── apps.py      # App configuration settings
│   │── models.py    # Defines database models
│   │── tests.py     # Contains test cases for the app
│   │── views.py     # Contains business logic (handles requests and responses)
│── templates/       # Stores HTML template files
│── static/          # Stores CSS, JavaScript, images, etc.

- MVC stands for Model–View–Controller, a software design pattern used to separate concerns in web applications.
- MVT is Django’s design pattern, a variation of MVC tailored for web development.
- Model handles the data: defines database structure, fields, and relationships.
- View contains business logic: processes requests, queries models, and returns responses.
- Template is the presentation layer: defines how data is displayed (HTML, CSS).
- Unlike MVC, Django’s framework itself acts as the Controller (URL dispatcher).
- Views in Django are Python functions/classes that link models and templates.
- Templates use Django Template Language (DTL) to dynamically generate HTML.
- Models are defined in models.py, and automatically linked to the database.
- Views are in views.py, and they fetch data from models and render templates.
- MVT ensures separation of concerns, making Django apps modular, maintainable, and scalable.


- VIEWS in django
- Views handle HTTP requests and return HTTP responses.
- They contain the logic for what happens when a user visits a specific URL.
- Views can be written as Function-Based Views (FBVs) or Class-Based Views (CBVs).
- Function-Based Views (FBV)
- Regular Python functions that take request as an argument.
- So python function takes request variable as an argument.
- We can simply define a function for view , then we can write logic in function and then we can return it.
- We can returnn HttpResponse just to get simple response.
- We can return render which can be use to render html or template , syntax is render(request,'a.html').
- We can return jsonresponse to return a json.
- We can also return redirect for redirecting to another url.
- We can import render or redirect from the django.shortcuts.
- We can import httpresponse , jsonresponse or httpresponsenotfound from django.http.
- We can use decorator (funcions to increase functionality of other function) like @require_http_methods to use differnt http method like @require_http_methods(["POST"]).
- We can import @require_http_method from django.views.decorators.http
- Common decorators:
    @require_http_methods(["GET", "POST"])
    @csrf_exempt
    @login_required (from django.contrib.auth.decorators)
- By default, Django requires CSRF tokens for POST methods.
- Use @csrf_exempt to bypass during testing (not recommended in production).
- We can import @csrf_exempt from django.views.decorators.csrf .
- Class-Based Views (CBV)
- We can also create classes for views just like functions.
- We can simply create a class which take View variable as an argument to initialise a class based view.
- We can import View for class from django.views.
- Inside class we can create a function with the http method name like def get() which take self,request as an argument then we can return it.
- We can use @method_decorators to use decorators in class based view.
- We can import method decorators from django.utils.decorators.
- We can use method decorator like - @method_decorator(csrf_exempt, name='dispatch').
- Organize logic into class methods like .get(), .post(), .put(), etc.
- We can use HttpResponseRedirect – redirects to another URL.
- We can use render(request, template, context) – shortcut to return HTML with context.
- Context is a dictionary passed from view to template.
- It contains data to be dynamically rendered in HTML using template syntax.
- We can also create dynamic views which accepts another value with the request like (request,id) which can be used to modify view.
- Django’s advanced views include TemplateView, ListView, DetailView, CreateView, UpdateView, DeleteView, and Mixins (e.g., LoginRequiredMixin) — all part of Generic Class-Based Views (GCBVs) that simplify common CRUD and page-rendering tasks by providing built-in logic for displaying, creating, updating, deleting, and securing data with minimal code.
- HTTP Method Handling
    You can filter request methods using if request.method == "POST".
    Or restrict methods using @require_http_methods.
    CBVs define get(), post(), put(), delete() methods.
- Error Views
    Custom views can return 404, 403, or other error responses.
    Django can also use custom error handlers: handler404, handler500, etc.
- URLS in django.
- Views include the logic for response but Urls are used to link a view with the url map hello_view with the hello/ url.
- Urls are created inside a urls.py file which exist at project level but we can create same like for app level to organise better.
- Urls.py file consist of the list name as url patterns and inside that list we can define paths.
- We can import path from django.urls.
- This path function simply take some arguments first is url like '' - home pr 'about/' , second is view to map it with url and third is name which is used for the unique identifier.
- We can simply import views inside the urls file like from . import views.
- We can simply use it like views.about_view.
- For urls which use class based views , we have to use .as_view() method to map view with url like - view.about_view.as_view().
- Example of a path - path('template/',views.template_view,name='template').
- We have to design the url for a dynamic view in a differnt way - 'hello/<str:name>/' so first argument in path should be like this means with hello url we are accepting a string value which we will use for name.
- For project level urls - we can put each application level url in project level urls.py.
- Same for project level urls we can define app urls in advance way , we can simply add all applevel views using include.
- We can import include from django.urls just like path.
- We can do it like this - path('',include('learnViews.urls')), #All learnViews URLS.
- Above example works like in a normal way , we can hit url by simply typing it but if we use url in above example instead of '' empty like - 'api2/' so we have to use api2/our view for all the learnViews app.
- Best Practices
    Keep views thin – avoid too much logic in views.
    Delegate database access to models and data formatting to templates.
    Use CBVs when you need reusability and structure.
    Use FBVs when logic is simple or highly customized.

